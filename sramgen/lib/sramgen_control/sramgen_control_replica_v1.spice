* Sramgen control circuit

* Standard cells
* .subckt sky130_fd_sc_lp__inv_2 A VGND VNB VPB VPWR Y
.subckt control_logic_inv din din_b vdd vss
X0 vss din din_b vss sky130_fd_pr__nfet_01v8 w=840000u l=150000u
X1 din_b din vdd vdd sky130_fd_pr__pfet_01v8_hvt w=1.26 l=150000u
X2 vdd din din_b vdd sky130_fd_pr__pfet_01v8_hvt w=1.26 l=150000u
X3 din_b din vss vss sky130_fd_pr__nfet_01v8 w=840000u l=150000u
.ends

* .subckt sky130_fd_sc_lp__buf_2 A VGND VNB VPB VPWR X
.subckt control_logic_buf A X vdd vss
X0 vss a_90_21# X vss sky130_fd_pr__nfet_01v8 w=840000u l=150000u
X1 vdd a_90_21# X vdd sky130_fd_pr__pfet_01v8_hvt w=1.26 l=150000u
X2 X a_90_21# vss vss sky130_fd_pr__nfet_01v8 w=840000u l=150000u
X3 X a_90_21# vdd vdd sky130_fd_pr__pfet_01v8_hvt w=1.26 l=150000u
X4 vdd A a_90_21# vdd sky130_fd_pr__pfet_01v8_hvt w=640000u l=150000u
X5 vss A a_90_21# vss sky130_fd_pr__nfet_01v8 w=420000u l=150000u
.ends

* .subckt sky130_fd_sc_lp__and2_2 A B VGND VNB VPB VPWR X
.subckt control_logic_and2 A B X vdd vss
X0 a_129_47# B vss vss sky130_fd_pr__nfet_01v8 w=420000u l=150000u
X1 vdd a_46_47# X vdd sky130_fd_pr__pfet_01v8_hvt w=1.26 l=150000u
X2 vss a_46_47# X vss sky130_fd_pr__nfet_01v8 w=840000u l=150000u
X3 X a_46_47# vss vss sky130_fd_pr__nfet_01v8 w=840000u l=150000u
X4 a_46_47# A a_129_47# vss sky130_fd_pr__nfet_01v8 w=420000u l=150000u
X5 X a_46_47# vdd vdd sky130_fd_pr__pfet_01v8_hvt w=1.26 l=150000u
X6 vdd A a_46_47# vdd sky130_fd_pr__pfet_01v8_hvt w=420000u l=150000u
X7 a_46_47# B vdd vdd sky130_fd_pr__pfet_01v8_hvt w=420000u l=150000u
.ends

.subckt control_logic_delay_chain4 din dout vdd vss
Xinv0 din tmp0 vdd vss control_logic_inv
Xinv1 tmp0 tmp1 vdd vss control_logic_inv
Xinv2 tmp1 tmp2 vdd vss control_logic_inv
Xinv3 tmp2 dout vdd vss control_logic_inv
.ends

.subckt sramgen_control clk we rbl pc_b wl_en write_driver_en sense_en vdd vss
* INPUT: clk we
* INOUT: rbl
* OUTPUT: pc_b wl_en write_driver_en sense_en
* INOUT: vdd vss

Xclk_pulse clk clkp vdd vss sramgen_edge_detector

* Turn on wordlines at start of cycle
* Turn them off when replica bitline drops low enough
* to flip an inverter.
Xinv_rbl rbl rbl_b vdd vss control_logic_inv
Xwl_ctl clkp rbl_b wl_en0 wl_en0_b vdd vss sramgen_sr_latch
Xwl_en_buf wl_en0 wl_en vdd vss control_logic_buf

* SAE = delay(rbl_b)
Xsae_delay_chain rbl_b sense_en vdd vss control_logic_delay_chain4

* Latch SAE to generate precharge bar
Xpc_delay_chain sense_en pc_set vdd vss control_logic_delay_chain4
Xpc_ctl pc_set clkp pc pc_b0 vdd vss sramgen_sr_latch
Xpc_b_buf pc_b0 pc_b vdd vss control_logic_buf

* clkp and we forms wr driver enable set signal
Xand_wr_en_set clkp we wr_drv_set0 vdd vss control_logic_and2
* Delay set signal a bit to ensure we don't turn on write drivers while precharging
Xwr_drv_set_delay_chain wr_drv_set0 wr_drv_set vdd vss control_logic_delay_chain4
Xwr_drv_ctl wr_drv_set sense_en write_driver_en0 write_driver_en_b vdd vss sramgen_sr_latch
Xwr_drv_buf write_driver_en0 write_driver_en vdd vss control_logic_buf
.ends

