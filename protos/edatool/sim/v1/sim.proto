// BSD 3-Clause License
// 
// Copyright (c) 2022, Rahul Kumar
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file contains ProtocolBuffer definitions for parsing simulation
// results generated by using EdaTool.

syntax = "proto3";

package edatool.sim.v1;

// Contains the results of running a single simulation.
// A simulation has an optional name, and a list of results
// corresponding to the different analyses performed.
//
// Typically, a simulation will correspond to one netlist.
message SimulationData {
  // The name of the simulation
  string name = 1;

  // A list of analyses performed
  repeated AnalysisData analyses = 2;
}

// Specifies how to sweep a variable
enum SweepMode {
  // The default SweepMode, used if no other
  // SweepMode is explicitly set.
  // Should not be used at all.
  // Will likely cause panics or errors if passed to EdaTool.
  SWEEP_MODE_UNSPECIFIED = 0;
  // Perform a linear sweep,
  // with a certain number of points within the sweep range.
  SWEEP_MODE_LINEAR = 1;
  // Perform a logarithmic sweep,
  // with a certain number of points per decade.
  SWEEP_MODE_DECADE = 2;
  // Perform a logarithmic sweep,
  // with a certain number of points per octave.
  SWEEP_MODE_OCTAVE = 3;
}

// The parameters to be used when performing a transient analysis.
message TranParams {
  // The simulation end time
  double tstop = 1;
  // An initial guess for the simulation step size
  double tstep = 2;
  // The simulation start time
  double tstart = 3;
  // Whether or not to use initial conditions
  // If false (default), the simulator will usually
  // run an operating point analysis before beginning
  // the transient simulation.
  // If true (not supported by EdaTool at the moment),
  // initial conditions must be manually specified.
  // For nodes where no initial condition is explicitly given,
  // the simulator will usually default to 0.
  bool uic = 4;
}

// The parameters to be used when performing an AC analysis.
message AcParams {
  // The type of frequency sweep to perform
  SweepMode sweep_mode = 1;
  // The number of points, number of points per decade,
  // or number of points per octave, depending on the
  // SweepMode used.
  uint64 num = 2;
  // The start frequency. The simulator will sweep
  // frequencies from the start frequency to the
  // stop frequency.
  double fstart = 3;
  // The stop frequency. The simulator will sweep
  // frequencies from the start frequency to the
  // stop frequency.
  double fstop = 4;
}

// The parameters to be used when performing a DC analysis.
message DcParams {
  // The name of the source whose value should be swept.
  string source = 1;
  // The start of the sweep range.
  double start = 2;
  // The end of the sweep range.
  double stop = 3;
  // The step size to use when sweeping.
  double incr = 4;
}

// The parameters to be used when performing an operating
// point (op) analysis.
message OpParams {
  // currently empty
}

// Indicates what type of simulation should be performed.
message AnalysisMode {
  // Indicates what type of simulation should be performed,
  // as well as the parameters to use for the simulation.
  oneof mode {
    TranParams tran = 1;
    AcParams ac = 2;
    DcParams dc = 3;
    OpParams op = 4;
  }
}

// A named expression.
//
// Corresponds to running a statement of the form
// 
// ```spice
// let {name} = {expr}
// ```
//
// in a simulator.
message NamedExpression {
  // The name of the expression.
  // 
  // The expression `expr` is evaluated, and the result
  // is assigned to `name`.
  string name = 1;

  // The actual expression to evaluate.
  // 
  // The expression `expr` is evaluated, and the result
  // is assigned to `name`.
  string expr = 2;
}

// An analysis to run.
//
// An analysis consists of an `AnalysisMode`,
// which specifies the type and parameters of the
// simulation, as well as a list of `NamedExpression`s,
// which specify the variables to save after the
// simulation is done.
message Analysis {
  // The type and parameters of the simulation.
  AnalysisMode mode = 1;
  // A list of expressions to save/export.
  repeated NamedExpression expressions = 2;
}

// A container for the results of a single `Analysis`.
message AnalysisData {
  // The type and parameters of the simulation that was run.
  AnalysisMode mode = 1;
  // A map of values exported by the analysis. These correspond
  // to the `NamedExpression`s specified in an `Analysis`.
  //
  // The keys are the names of expressions, and the values
  // are `SimVector`s representing the results of evaluating
  // those expressions.
  map<string, SimVector> values = 2;
}

// A vector of data produced by a simulation.
message SimVector {
  // The (optional) name of the vector.
  string name = 1;
  // The values contained in the vector.
  oneof values {
    RealVector real = 2;
    ComplexVector complex = 3;
  }
}

// A vector of real-valued data.
message RealVector {
  // A list of double-precision floats storing the data.
  repeated double v = 1;
}

// A vector of complex-valued data.
message ComplexVector {
  // A list of double-precision floats storing the real component of the data.
  repeated double a = 1;
  // A list of double-precision floats storing the imaginary component of the data.
  repeated double b = 2;
}
