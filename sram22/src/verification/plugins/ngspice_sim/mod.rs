use crate::error::{Result, Sram22Error};
use crate::verification::sim::analysis::{Analysis, AnalysisData, Mode, SpiceData};
use crate::verification::sim::testbench::{NetlistSource, Testbench};
use std::collections::HashMap;
use std::fs::{self, read_to_string, File};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;
use std::{
    path::PathBuf,
    process::{Child, ChildStdin, Command, Stdio},
};

#[cfg(test)]
mod tests;

pub struct Ngspice {
    cwd: Option<PathBuf>,
    tb: Option<Testbench>,
    analyses: Vec<Analysis>,
    control: String,
}

pub struct NgspiceData {}

impl Ngspice {
    #[inline]
    pub fn cwd(mut self, cwd: PathBuf) -> Self {
        self.cwd = Some(cwd);
        self
    }
    #[inline]
    pub fn tb(mut self, tb: Testbench) -> Self {
        self.tb = Some(tb);
        self
    }

    pub fn add_analysis(&mut self, a: Analysis) -> &mut Self {
        self.analyses.push(a);

        let spice_line = self.prepare_spice_analysis(&a.mode);
        self.control.push_str(&spice_line);

        let out_file = format!("_ngspice_out_{}.m", self.analyses.len());
        if a.save.len() > 0 {
            let mut wrdata = format!("wrdata {}", out_file);
            for v in a.save.iter() {
                wrdata.push_str(&format!(" {}", v));
            }
            self.control.push_str(&wrdata);
        }

        self
    }

    pub fn run(self) -> Result<NgspiceData> {
        let cwd = if let Some(cwd) = self.cwd.as_ref() {
            cwd.to_owned()
        } else {
            std::env::current_dir()?
        };
        let tb = self.tb.as_ref().unwrap();

        fs::create_dir_all(&cwd)?;

        let path = self.write_tb_to_file(&cwd, &tb);

        let mut cmd = Command::new("ngspice");
        cmd.arg("-b");

        cmd.current_dir(&cwd);

        cmd.stdin(Stdio::null())
            .stdout(Stdio::inherit())
            .stderr(Stdio::null());
        let mut child = cmd.spawn()?;
        child.wait()?;

        Ok(NgspiceData {})
    }

    fn write_tb_to_file(&self, cwd: impl AsRef<Path>, tb: &Testbench) -> Result<PathBuf> {
        let path = cwd.as_ref().join("ztop.spice");
        let mut f = File::create(&path)?;
        self.write_tb(&mut f, tb)?;
        f.flush()?;
        Ok(path)
    }

    fn write_tb<T>(&self, dst: &mut T, tb: &Testbench) -> Result<()>
    where
        T: Write,
    {
        let title = tb.name().unwrap_or("Netlist generated by Sram22");

        // TODO includes, libs

        writeln!(dst, "* {}", title)?;
        match tb.source() {
            NetlistSource::Str(s) => writeln!(dst, "{}", s)?,
            NetlistSource::File(p) => {
                let s = read_to_string(p)?;
                writeln!(dst, "{}", s)?;
            }
        }

        writeln!(dst, ".control")?;
        writeln!(dst, "{}", self.control)?;
        writeln!(dst, ".endc")?;
        writeln!(dst, ".end")?;
        Ok(())
    }

    pub fn run_analysis(&mut self, a: &Analysis) -> Result<AnalysisData> {}

    fn prepare_spice_analysis(&self, m: &Mode) -> String {
        match *m {
            Mode::Op => "op".to_string(),
            _ => todo!(),
        }
    }
}

fn read_analysis_data(a: &Analysis, out_file: impl AsRef<Path>) -> Result<AnalysisData> {
    let f = File::open(out_file)?;
    let reader = BufReader::new(f);
    let data: Vec<Vec<f64>> = reader
        .lines()
        .map(|line| {
            let line = line?;
            let row = line
                .trim()
                .split_whitespace()
                .map(|s| s.parse::<f64>())
                .collect::<std::result::Result<Vec<_>, _>>()
                .map_err(|_| {
                    Sram22Error::FileFormat(
                        "invalid output data format from ngspice simulation".to_string(),
                    )
                })?;
            Ok::<Vec<f64>, Sram22Error>(row)
        })
        .collect::<std::result::Result<Vec<_>, _>>()?;

    let complex = false;

    // sweep var is 1st col
    let mut sweep_var = Vec::new();
    let mut results = HashMap::new();

    for row in data.into_iter() {
        sweep_var.push(row[0]);
        let mut counter = 1;
        for v in a.save.iter() {
            if let Some(entry) = results.get_mut(v) {
                match entry {
                    SpiceData::Complex(ref mut a, ref mut b) => {
                        a.push(row[counter]);
                        b.push(row[counter + 1]);
                        counter += 3;
                    }
                    SpiceData::Real(ref mut x) => {
                        x.push(row[counter]);
                        counter += 2;
                    }
                }
            } else {
                if complex {
                    results.insert(v.to_string(), SpiceData::Complex(Vec::new(), Vec::new()));
                } else {
                    results.insert(v.to_string(), SpiceData::Real(Vec::new()));
                }
            }
        }
    }

    if results.contains_key("sweep_var") {
        return Err(Sram22Error::FileFormat(
            "cannot have variable named `sweep_var` in results".to_string(),
        ));
    }

    results.insert("sweep_var".to_string(), SpiceData::Real(sweep_var));

    Ok(AnalysisData { data: results })
}
