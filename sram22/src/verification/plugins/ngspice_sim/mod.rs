use crate::error::{Result, Sram22Error};
use crate::verification::sim::analysis::{Analysis, AnalysisData, Mode, SpiceData};
use crate::verification::sim::testbench::{NetlistSource, Testbench};
use std::collections::HashMap;
use std::fs::{self, read_to_string, File};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;
use std::{
    path::PathBuf,
    process::{Command, Stdio},
};

#[cfg(test)]
mod tests;

pub struct Ngspice {
    cwd: Option<PathBuf>,
    tb: Testbench,
    analyses: Vec<Analysis>,
    control: String,
}

pub struct NgspiceData {
    pub analyses: Vec<AnalysisData>,
}

impl Ngspice {
    pub fn with_tb(tb: Testbench) -> Self {
        Self {
            cwd: None,
            tb,
            analyses: vec![],
            control: "".to_string(),
        }
    }

    #[inline]
    pub fn cwd(&mut self, cwd: PathBuf) -> &mut Self {
        self.cwd = Some(cwd);
        self
    }

    pub fn add_analysis(&mut self, a: Analysis) -> &mut Self {
        let spice_line = self.prepare_spice_analysis(&a.mode);
        self.control.push_str(&spice_line);

        let out_file = get_out_file(self.analyses.len());
        if !a.save.is_empty() {
            let mut wrdata = format!("wrdata {}", out_file);
            for v in a.save.iter() {
                wrdata.push_str(&format!(" {}", v));
            }
            self.control.push_str(&wrdata);
            self.control.push('\n');
        }

        self.analyses.push(a);

        self
    }

    pub fn run(self) -> Result<NgspiceData> {
        let cwd = if let Some(cwd) = self.cwd.as_ref() {
            cwd.to_owned()
        } else {
            std::env::current_dir()?
        };

        fs::create_dir_all(&cwd)?;

        let path = self.write_tb_to_file(&cwd, &self.tb)?;

        let mut cmd = Command::new("ngspice");
        cmd.arg("-b");
        cmd.arg(path);

        cmd.current_dir(&cwd);

        cmd.stdin(Stdio::null())
            .stdout(Stdio::inherit())
            .stderr(Stdio::null());
        let mut child = cmd.spawn()?;
        child.wait()?;

        let analyses = self
            .analyses
            .iter()
            .enumerate()
            .map(|(i, a)| {
                let out_file_path = cwd.join(get_out_file(i));
                println!("reading from {:?}", &out_file_path);
                let data = read_analysis_data(a, out_file_path)?;
                Ok(data)
            })
            .collect::<Result<Vec<_>>>()?;

        Ok(NgspiceData { analyses })
    }

    fn write_tb_to_file(&self, cwd: impl AsRef<Path>, tb: &Testbench) -> Result<PathBuf> {
        let path = cwd.as_ref().join("ztop.spice");
        let mut f = File::create(&path)?;
        self.write_tb(&mut f, tb)?;
        f.flush()?;
        Ok(path)
    }

    fn write_tb<T>(&self, dst: &mut T, tb: &Testbench) -> Result<()>
    where
        T: Write,
    {
        let title = tb.name().unwrap_or("Netlist generated by Sram22");

        writeln!(dst, "* {}", title)?;

        for include in tb.includes() {
            writeln!(dst, ".include {}", include.to_str().unwrap())?;
        }

        for lib in tb.libs() {
            writeln!(
                dst,
                ".lib {} {}",
                lib.path.to_str().unwrap(),
                lib.name.as_deref().unwrap_or("")
            )?;
        }

        match tb.source() {
            NetlistSource::Str(s) => writeln!(dst, "{}", s)?,
            NetlistSource::File(p) => {
                let s = read_to_string(p)?;
                writeln!(dst, "{}", s)?;
            }
        }

        writeln!(dst, ".control")?;
        writeln!(dst, "{}", self.control)?;
        writeln!(dst, ".endc")?;
        writeln!(dst, ".end")?;
        Ok(())
    }

    fn prepare_spice_analysis(&self, m: &Mode) -> String {
        match *m {
            Mode::Op => "op\n".to_string(),
            Mode::Tran(ref m) => {
                let uic = if m.uic { "uic" } else { "" };
                format!("tran {}s {}s {}s {}\n", m.tstep, m.tstop, m.tstart, uic)
            }
            Mode::Dc(ref m) => {
                format!("dc {} {} {} {}\n", m.source, m.start, m.stop, m.incr)
            }
            Mode::Ac(ref m) => {
                format!("ac {} {} {} {}", m.mode, m.num, m.fstart, m.fstop)
            }
        }
    }
}

fn get_out_file(id: usize) -> String {
    format!("_ngspice_out_{}.m", id)
}

fn read_analysis_data(a: &Analysis, out_file: impl AsRef<Path>) -> Result<AnalysisData> {
    let f = File::open(out_file)?;
    let reader = BufReader::new(f);
    let data: Vec<Vec<f64>> = reader
        .lines()
        .map(|line| {
            let line = line?;
            let row = line
                .trim()
                .split_whitespace()
                .map(|s| s.parse::<f64>())
                .collect::<std::result::Result<Vec<_>, _>>()
                .map_err(|_| {
                    Sram22Error::FileFormat(
                        "invalid output data format from ngspice simulation".to_string(),
                    )
                })?;
            Ok::<Vec<f64>, Sram22Error>(row)
        })
        .collect::<std::result::Result<Vec<_>, _>>()?;

    // Results will be complex numbers if running AC analysis
    let complex = matches!(a.mode, Mode::Ac(_));

    // sweep var is 1st col
    let mut sweep_var = Vec::new();
    let mut results = HashMap::new();

    for row in data.into_iter() {
        sweep_var.push(row[0]);
        let mut counter = 1;
        for v in a.save.iter() {
            if !results.contains_key(v) {
                if complex {
                    results.insert(v.to_string(), SpiceData::Complex(Vec::new(), Vec::new()));
                } else {
                    results.insert(v.to_string(), SpiceData::Real(Vec::new()));
                }
            }
            if let Some(entry) = results.get_mut(v) {
                match entry {
                    SpiceData::Complex(ref mut a, ref mut b) => {
                        a.push(row[counter]);
                        b.push(row[counter + 1]);
                        counter += 3;
                    }
                    SpiceData::Real(ref mut x) => {
                        x.push(row[counter]);
                        counter += 2;
                    }
                }
            } else {
                unreachable!();
            }
        }
    }

    if results.contains_key("sweep_var") {
        return Err(Sram22Error::FileFormat(
            "cannot have variable named `sweep_var` in results".to_string(),
        ));
    }

    results.insert("sweep_var".to_string(), SpiceData::Real(sweep_var));

    Ok(AnalysisData { data: results })
}
