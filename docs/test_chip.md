# STAC: SRAM Timing Analysis Chip

High-level information:
* Submitting to Efabless ChipIgnite 2306Q
* Tapeout deadline: June 5, 2023
* Chips (supposedly) delivered: October 27, 2023
* Package: QFN, 64 pins
* [I/O map](https://docs.google.com/spreadsheets/d/1pwuNWhKo4AzVCC_3EHxcBpiF1-V-zbCteOw8ayxvDU0/edit#gid=2022539742) (WIP)
* [Top level repo](https://github.com/ucb-bar/stac-top)

# Organization

A rough top-level diagram of the chip is shown below:

![STAC top level diagram](./figures/stac_top.svg)

Each SRAM test block contains the following elements:

![A single SRAM test block](./figures/sram22_test_block.svg)

Update: Rather than having one BIST block per SRAM, there will instead
be one BIST pattern generator shared across all SRAMs.

To the extent possible, the top level will be generated
by Chipyard/Hammer.

## Rocket

* A TinyRocket instance generated by Chipyard
* Has an option to allow all internal SRAMs to by bypassed
* Communicates with the SRAM test blocks via memory-mapped I/O

The Rocket communicates with the SRAM test blocks via MMIO only.
The test blocks do not participate in the memory hierarchy of the core.

## SRAM Test Blocks

The SRAM test area uses the following pins:
* `clk`: The global clock.
* `reset`: The global reset signal.
* `SRAM_SCAN_IN`: SRAM scan chain input.
* `SRAM_SCAN_OUT`: SRAM scan chain output.
* `SRAM_SCAN_EN`: Enables scan chain mode.
* `SRAM_SAE_CLK`: The clock used to drive the SRAM sense amplifiers.
* `SRAM_EXT_EN`: Enables external control of SRAMs (used only for **manual test mode (MTM)**).
* `SRAM_SCAN_MODE`: Whether scan chain is using scanned inputs or Rocket inputs.
* `SRAM_EN`: A global chip enable for all SRAM blocks. When setting up SRAM inputs (via scan chain or MMIO), should be held low; once the inputs are ready and stable, this should be set high (usually for one cycle). Similarly, should be held low when reading from the TDC output.
* `BIST_EN`: Enables all BIST modules when in test mode.
* `BIST_DONE`: Indicates that the BIST has completed its test.

There are three modes of test operation:
* Rocket-controlled testing over memory-mapped I/O (MMIO).
  Programmable test pattern, but limited speed due to needing to fetch instructions from memory
  and synchronize TDC output. Roughly 5-10 cycles per operation.
    1. `SRAM_EXT_EN` and `SRAM_SCAN_MODE` held low. 
    2. SRAM enable controlled by FSM that begins execution when MMIO writes to `ex` register.
    3. `sram_sel` register set to `SRAM_SEL_MMIO`, indicating that the SRAMs should take inputs directy from MMIO registers.
    2. SRAM enable controlled by FSM that begins execution when MMIO writes to `ex` register. Once execution begins, the FSM should turn on `sram_en_int` for one cycle to trigger a single memory operation.
    4. Once the operation is complete and the correct values of `dout` and `tdc` are stored in scan chain after an additional cycle, the FSM will set `done` to high, allowing the Rocket to read the relevant values. _Operates under the assumption that `dout` and `tdc` will not change due to the SRAMs being disabled on the next clock cycle (i.e. that clock gating works correctly)._
* Manual test mode (MTM). Enables testing via scan chain.
  Can scan inputs into registers, then scan out SRAM output.
    1. `SRAM_EXT_EN` and `SRAM_SCAN_MODE` held high. 
    2. Values are scanned into the registers and held (Rocket cannot write to MMIO registers while `SRAM_SCAN_MODE` is high).
    3. `sram_sel` register set to `SRAM_SEL_MMIO`, indicating that the SRAMs should take inputs directy from MMIO registers 
    2. SRAM enabled by external `SRAM_EN` signal for one cycle.
    4. Once the operation is complete and the correct values of `dout` and `tdc` are stored in scan chain, results canbe scanned out.
  Slow (~1k cycles per op), but does not rely on Rocket or BIST working.
* Built-in self-test (BIST) via MMIO. Performs at-speed (1 op per cycle) testing of predefined memory patterns.
    1. `SRAM_EXT_EN` and `SRAM_SCAN_MODE` held low. 
    2. SRAM enable controlled by BIST.
    3. `sram_sel` register set to `SRAM_SEL_BIST`, indicating that the SRAMs should take inputs from the BIST.
    2. BIST controlled by FSM that begins execution when MMIO writes to `ex` register. The FSM writes `start` signal to reset BIST counters for one (or more) cycles, then enables the BIST.
    4. Once the test is complete, the BIST will write to the `done` register. The rocket can then read the relevant MMIO registers for the test results.
* Built-in self-test (BIST) via scan chain. Performs at-speed (1 op per cycle) testing of predefined memory patterns.
    1. `SRAM_EXT_EN` is held low, and `SRAM_SCAN_MODE` is held high.
    2. Global reset set in order to reset BIST (`BIST_EN` held low).
    2. SRAM enable controlled by BIST.
    3. Values are scanned into the registers and held (Rocket cannot write to MMIO registers while `SRAM_SCAN_MODE` is high).
    4. `sram_sel` register set to `SRAM_SEL_BIST`, indicating that the SRAMs should take inputs from the BIST.
    5. Ocne registers are all scanned in, `BIST_EN` is set high, starting the BIST test.
    4. Once the test is complete, the BIST will write to the `done` register, which can be read externally via the `DONE` pin. The test results can then be scanned out.

Note that there are no dual-clock scan chain FFs in the open-source SKY130 PDK.
(Dual-clock FFs have a scan clock port and an independent system clock port.)

Alongside the global BIST, there will be a shared MMIO controller.
The MMIO controller enables the Rocket to read/write to the SRAMs directly,
without the need for programming a pattern into the BIST.
The MMIO controller is described in more detail below.

Clock should be held low when not in use.

### Memory Faults

BIST patterns are meant to identify common classes of faults:
* Stuck-at faults (SAFs): A cell's value is always 0 or 1; it cannot be changed.
  A test that reads a 0 and a 1 from every cell detects all SAFs.
* Stuck-open faults (SOpFs): A cell cannot be accessed (eg. due to an open wordline).
  Attempting to read a cell with a SOpF results in either a 0 or 1, depending on
  the offset voltage of the sense amplifier in that cell's column. The read value
  is, to first order, independent of the value in the cell.
  It is also repeatable: if one read of a SOpF cell produces a 0, subsequent reads
  should also produce a 0.
* Transition faults (TFs): A cell cannot be set to 0, cannot be set to 1, or both.
  To detect all TFs, a test must transition each cell from 0 to 1
  and from 1 to 0, and the correct cell value must be read after each transition.
  (Note that writing a 1 is not exactly the same as causing a transition to 1. A transition
  to 1 only occurs when the cell stores a 0 and is written with a 1.)
* Data retention faults (DRFs): A cell loses its value after some amount of time.
  These faults can be caused by faulty pull-up transistors.
* Coupling faults (CFs): Transitions or patterns in aggressor cells cause a fault in a victim cell.
  There are a few types of CFs:
  * Inversion coupling faults (CFins): A transition in an aggressor cell flips the contents of the victim cell.
    A test to detect all CFins must read each victim cell after performing an odd number of transitions
    on potential aggressor cells.
  * Idempotent coupling faults (CFids): A transition in an aggressor cell sets the contents of the victim cell to 0 or 1.
    A test to detect all CFids must read each victim cell after performing transitions on potential aggressor cells.
    The potential CFids triggered should not mask each other.
  * State coupling faults (CFsts): The values in one or more aggressor cells force a victim cell to a certain value.
* Address decoder faults (AFs):
  * An address does not access any cells
  * A cell is not accessed by any address
  * A single address accesses multiple cells
  * A cell can be accessed by multiple addresses

A few BIST patterns are described below.

#### MATS+

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1 | up |
| 3 | r1, w0 | down |

Test length: `5n`

Faults detected: All SAFs and AFs.

#### March C-

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1 | up |
| 3 | r1, w0 | up |
| 4 | r0, w1 | down |
| 5 | r1, w0 | down |
| 6 | r0 | up/down |

Test length: `10n`

Faults detected: Unlinked CFids, AFs, SAFs, CFsts, TFs, CFins not linked with CFids.

#### March A

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1, w0, w1 | up |
| 3 | r1, w0, w1 | up |
| 4 | r1, w0, w1, w0 | down |
| 5 | r0, w1, w0 | down |

Test length: `15n`

Faults detected: Linked CFids, AFs, SAFs, TFs not linked with CFids, some CFins linked with CFids.

#### March B

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1, r1, w0, r0, w1 | up |
| 3 | r1, w0, w1 | up |
| 4 | r1, w0, w1, w0 | down |
| 5 | r0, w1, w0 | down |

Test length: `17n`

Faults detected: All faults detected by March A, as well as TFs linked with CFins or CFids.


### Programmable BIST

The goal of the programmable BIST engine is to enable at-speed (1 cycle per op) testing for patterns
that we anticipate will expose faults. It only supports common memory test patterns. For fully
general pattern generation, the Rocket should be used.

There will be one programmable BIST engine shared across all SRAM test macros.

The BIST requires the following run-time configuration:
* `MAX_ROW_ADDR`: The maximum row address (inclusive).
* `MAX_COL_ADDR`: The maximum col address (inclusive).
* `INNER_DIM`: Set to `ROWS` or `COLS`; determines whether row or column addresses, respectively,
  are in the inner loop of all march sequences.

The BIST also stores (in flip flops) a data background pattern table (DBPT).
This table can be programmed by the scan chain or by the Rocket.
Although the table is shown for 4 bit data, the true data size is
determined by the maximum SRAM width being tested.

| Address | Data |
| --- | --- |
| 0 | 0000 |
| 1 | 1111 |
| 2 | 0101 |
| 3 | 1010 |
| 4 | 0101 |
| 5 | 0011 |
| 6 | 1100 |

The BIST supports the following instructions:
* `RESET seed`: Resets signature registers and seeds the pseudo-random number generator.
* `WAIT n`: Waits for `N` clock cycles.
* `MARCH e0 [, e1, ...] { UP | DOWN }`: marches up or down the address space,
  performing the march operations `e0`, `e1`, ...
  The possible march operations are `{READ | WRITE} pattern_address [ FLIP ]`.
  For example, the march operation `READ 5 FLIP` checks that each read operation returns the bit
  sequence `1100`, which is the bitwise complement of pattern 5 in the table above.
* `RAND re0 [, re1, ...] { RA N | UP | DOWN }`: Runs a pseudo-random test.
  If `UP` or `DOWN` is specified, marches up or down (respectively) the address space,
  performing the random elements `RE0`, `RE1`, ...
  If `RA` is specified, a pseudo-random address is used. The integer `N` specifies how many
  addresses to pick. For example, `RAND OP WRITE 0, READ RA 3` picks three (not necessarily distinct)
  addresses, and for each address, writes the pattern stored in address 0 of the DBPT and then reads it back.
  Each random operation has the following structure: `OP { READ | WRITE | RAND } [ DATA { pattern_address | RAND } MASK {pattern_address | 1 | RAND } ]`.
  * `OP`: can be `READ`, `WRITE`, or `RAND`. If `RAND`, an operation (read/write) will be selected pseudo-randomly.
  * `DATA`: can be a pattern address, or `RAND`. If `RAND`, data will be selected pseudo-randomly. If a pattern address is given,
    the data to write will be pulled from the data background pattern table.
  * `MASK`: can be a pattern address, `1`, or `RAND`. If `1`, the write mask will be all 1s. If `RAND`, the mask
    will be selected pseudo-randomly. If a pattern address, the mask pattern will be pulled from the DBPT.
  The `DATA` and `MASK` fields are required for `WRITE` and `RAND` operations; they must be left blank for `READ` operations.

All pseudo-random data is drawn from an [LFSR](https://en.wikipedia.org/wiki/Linear-feedback_shift_register).

The BIST continuously outputs a signature. This signature can be compared to an expected signature
to determine where a test has failed. On every read operation, the value read from memory
is hashed into the signature.

For march instructions, if the memory produces an incorrect
value upon read, the BIST will provide the failing instruction, the address at which the failure
occurred, the data read, and the data expected.


### Scan Chain

Each scan chain register looks approximately like this:

![Scan chain register](./figures/scan_flop.jpg)

Note that there is only one clock. So moving data in and out of the scan chains
requires toggling the global clock.

When scan enable (SE) is high, the scan chain behaves like a shift register.
Data is shifted in from the scan in (SI) port, and shifted out at the scan out (SO)
port. In the diagram above, Q and SO are always the same value.


### MMIO Structure

The MMIO controller exposes the following memory-mapped registers.

| Name     | Width | Direction     | Description         | Note       |
| -------- | ----- | ------------- | ------------------- | ---------- |
| `addr`   | 13    | R/W           | Read/write address  | |
| `din`    | 32    | R/W           | Write data          | |
| `wmask`  | 32    | R/W           | Write mask          | |
| `we`     | 1     | R/W           | Write enable        | |
| `sram_id`| 4     | R/W           | The ID of the SRAM on which the operation should be performed | |
| `sram_sel`| 1     | R/W           | The SRAM input selector | |
| `sae_ctl`| 7     | R/W           | Delay line tuning parameter | Binary encoded |
| `sae_sel`| 2     | R/W           | SAE input selector| |
| `dout`   | 32    | RO            | Data read from SRAM | |
| `tdc`    | 252   | RO            | TDC output code     | Thermometer encoded |
| `ex`     | 1     | WO            | Set high for one cycle to begin a mem op | Not on scan chain |
| `done`   | 1     | RO            | High when a mem op completes. Turned off on a subsequent execute. | Not on scan chain

Widths are specified in bits.
For the direction field:
* R/W means the register is readable and writable.
* RO means the register is read-only.
* WO means the register is write-only.

The `sram_sel` control signal supports the following values:
* `SRAM_SEL_BIST`: configures the SRAMs to take input from the BIST.
* `SRAM_SEL_MMIO`: configures the SRAMs to take input from the MMIO registers.

Each SRAM operation will take approximately 5 cycles to complete:
1 cycle to set up SRAM inputs, 1 cycle for operation, and 3 cycles for TDC synchronization.
Upon completion of the operation, the `done` flag is raised. It is
set back to low when another memory operation begins (via writing to the `ex` register).

There are also MMIO registers for the BIST.

| Name     | Width | Direction     | Description         | 
| -------- | ----- | ------------- | ------------------- |
| `bist_sram_id` | 4   | R/W | The ID of the SRAM to test |
| `bist_rand_seed` | 77   | R/W | BIST PRNG (LFSR) seed |
| `bist_sig_seed` | 32   | R/W | BIST signature register (MISR) seed |
| `bist_max_row_addr` | 10   | R/W | BIST max row address |
| `bist_max_col_addr` | 3   | R/W | BIST max col address |
| `bist_inner_dim` | 1   | R/W | BIST inner dimension (rows or cols) |
| `bist_insts` | TBD   | R/W | BIST instruction table |
| `bist_patterns` | TBD   | R/W | BIST data background pattern table |
| `bist_cycle_limit` | 32   | R/W | Stops BIST execution after this many cycles |
| `bist_fail` | 1 | RO            | High if a failure was detected |
| `bist_fail_cycle` | 32 | RO            | The cycle at which the BIST detected the first failure |
| `bist_expected` | 32 | RO            | BIST expected data |
| `bist_received` | 32 | RO            | BIST received data |
| `bist_signature` | 32 | RO            | The value in the signature register at the end of the test |

The BIST stops executing and asserts the `bist_done` flag when:
* All BIST instructions have been executed.
* The first failure is detected (note that the BIST cannot detect errors in random tests).
* The `bist_cycle_limit` is reached.

The `bist_fail` flag is asserted when a failure in a deterministic test is detected.
Again, the BIST cannot detect errors in random tests, so the `bist_fail` flag
is meaningless for random tests. Instead, the signature register should be checked.

Note that prior to beginning a BIST test, the `sram_sel` MMIO register must be set to `SRAM_SEL_BIST`.

### TDC Configuration

The TDC takes as input an early clock and a late clock. It measures the time difference between
a rising edge of the early clock and a rising edge of the late clock, and produces a
thermometer-encoded digital signal. In the absence of rising edges on the late clock,
the TDC value is held constant.

Need GDS, LIB, LEF, SPICE, Verilog synth, Verilog sim.

## PLL

Sean may provide a BAG/Hammer-generated PLL instance,
with Spice/GDS/LEF/LIB collateral.

A global clock mux selects between the PLL-generated clock
and an externally-provided clock.
