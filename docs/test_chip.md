# STAC: SRAM Timing Analysis Chip

High-level information:
* Submitting to Efabless ChipIgnite 2306Q
* Tapeout deadline: June 5, 2023
* Chips (supposedly) delivered: October 27, 2023
* Package: QFN, 64 pins
* [I/O map](https://docs.google.com/spreadsheets/d/1pwuNWhKo4AzVCC_3EHxcBpiF1-V-zbCteOw8ayxvDU0/edit#gid=2022539742) (WIP)

# Organization

A rough top-level diagram of the chip is shown below:

![STAC top level diagram](./figures/stac_top.svg)

Each SRAM test block contains the following elements:

![A single SRAM test block](./figures/sram22_test_block.svg)

To the extent possible, the top level will be generated
by Chipyard/Hammer.

## Rocket

* A TinyRocket instance generated by Chipyard
* Has an option to allow all internal SRAMs to by bypassed
* Communicates with the SRAM test blocks via memory-mapped I/O

The Rocket communicates with the SRAM test blocks via MMIO only.
The test blocks do not participate in the memory hierarchy of the core.

## SRAM Test Blocks

The SRAM test area uses the following pins:
* `clk`: The global clock
* `SRAM_SCAN_IN`: SRAM scan chain input
* `SRAM_SCAN_OUT`: SRAM scan chain output
* `SRAM_SCAN_RSTB`: Resets the SRAM scan chain to all 0s
* `SRAM_SCAN_EN`: Enables scan chain mode
* `SRAM_SAE_CLK`: The clock used to drive the SRAM sense amplifiers
* `SRAM_RSTB`:  An active-low reset for all SRAM test circuitry, except the scan chain.
* `TDC_EN`: Enables all TDCs. When low, TDCs holds their values.
* `SRAM_EN`: A global chip enable for all SRAM blocks. When setting up SRAM inputs (via scan chain or MMIO), should be held low; once the inputs are ready and stable, this should be set high (usually for one cycle).
* `BIST_EN`: Enables all BIST modules.
* `SRAM_TEST_EN`: Enables manual test mode for all SRAMs.
   When high, SRAMs are enabled by `SRAM_EN`.
   When low, SRAMs are enabled by the SRAM enable Rocket MMIO register.

There are three modes of test operation:
* Built-in self-test (BIST). Performs at-speed (1 op per cycle) testing of predefined memory patterns.
* Rocket-controlled testing over memory-mapped I/O (MMIO).
  Programmable test pattern, but limited speed due to needing to fetch instructions from memory
  and synchronize TDC output. Roughly 5-10 cycles per operation.
* Testing via scan chain. Can scan inputs into registers, then scan out SRAM output.
  Slow (~1k cycles per op), but does not rely on Rocket or BIST working.

Note that there are no dual-clock scan chain FFs in the open-source SKY130 PDK.
(Dual-clock FFs have a scan clock port and an independent system clock port.)

```verilog
// Signals for the i'th SRAM block
assign sram_en_i = SRAM_TEST_EN ? SRAM_EN : mmio_sram_en;
assign sram_sel_i = SRAM_TEST_EN ? scan_sram_sel : mmio_sram_sel;

// `tdc_en_i` is an input to the TDC clock gating cell described in the TDC config section
assign tdc_en_i = SRAM_TEST_EN ? TDC_EN : mmio_tdc_en;

always @(*) begin
  case (sram_sel_i)
    SRAM_SEL_BIST : addr_i = bist_addr_i;
    SRAM_SEL_SCAN: addr_i = scan_addr_i;
    SRAM_SEL_MMIO: addr_i = mmio_addr_i;
    default: addr_i = 0;
  endcase
end
```

scan chain -> mux -> sram
register (from mmio) -> mux

Clock should be held low when not in use.

### Memory Faults

BIST patterns are meant to identify common classes of faults:
* Stuck-at faults (SAFs): A cell's value is always 0 or 1; it cannot be changed.
  A test that reads a 0 and a 1 from every cell detects all SAFs.
* Stuck-open faults (SOpFs): A cell cannot be accessed (eg. due to an open wordline).
  Attempting to read a cell with a SOpF results in either a 0 or 1, depending on
  the offset voltage of the sense amplifier in that cell's column. The read value
  is, to first order, independent of the value in the cell.
  It is also repeatable: if one read of a SOpF cell produces a 0, subsequent reads
  should also produce a 0.
* Transition faults (TFs): A cell cannot be set to 0, cannot be set to 1, or both.
  To detect all TFs, a test must transition each cell from 0 to 1
  and from 1 to 0, and the correct cell value must be read after each transition.
  (Note that writing a 1 is not exactly the same as causing a transition to 1. A transition
  to 1 only occurs when the cell stores a 0 and is written with a 1.)
* Data retention faults (DRFs): A cell loses its value after some amount of time.
  These faults can be caused by faulty pull-up transistors.
* Coupling faults (CFs): Transitions or patterns in aggressor cells cause a fault in a victim cell.
  There are a few types of CFs:
  * Inversion coupling faults (CFins): A transition in an aggressor cell flips the contents of the victim cell.
    A test to detect all CFins must read each victim cell after performing an odd number of transitions
    on potential aggressor cells.
  * Idempotent coupling faults (CFids): A transition in an aggressor cell sets the contents of the victim cell to 0 or 1.
    A test to detect all CFids must read each victim cell after performing transitions on potential aggressor cells.
    The potential CFids triggered should not mask each other.
  * State coupling faults (CFsts): The values in one or more aggressor cells force a victim cell to a certain value.
* Address decoder faults (AFs):
  * An address does not access any cells
  * A cell is not accessed by any address
  * A single address accesses multiple cells
  * A cell can be accessed by multiple addresses

A few BIST patterns are described below.

#### MATS+

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1 | up |
| 3 | r1, w0 | down |

Test length: `5n`

Faults detected: All SAFs and AFs.

#### March C-

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1 | up |
| 3 | r1, w0 | up |
| 4 | r0, w1 | down |
| 5 | r1, w0 | down |
| 6 | r0 | up/down |

Test length: `10n`

Faults detected: Unlinked CFids, AFs, SAFs, CFsts, TFs, CFins not linked with CFids.

#### March A

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1, w0, w1 | up |
| 3 | r1, w0, w1 | up |
| 4 | r1, w0, w1, w0 | down |
| 5 | r0, w1, w0 | down |

Test length: `15n`

Faults detected: Linked CFids, AFs, SAFs, TFs not linked with CFids, some CFins linked with CFids.

#### March B

Pattern:

| Element | Operations | Address direction |
| --- | --- | --- |
| 1 | w0 | up/down |
| 2 | r0, w1, r1, w0, r0, w1 | up |
| 3 | r1, w0, w1 | up |
| 4 | r1, w0, w1, w0 | down |
| 5 | r0, w1, w0 | down |

Test length: `17n`

Faults detected: All faults detected by March A, as well as TFs linked with CFins or CFids.


### Programmable BIST

The goal of the programmable BIST engine is to enable at-speed (1 cycle per op) testing for patterns
that we anticipate will expose faults. It only supports common memory test patterns. For fully
general pattern generation, the Rocket should be used.

There will be one programmable BIST engine shared across all SRAM test macros.

The BIST requires the following run-time configuration:
* `MAX_ROW_ADDR`: The maximum row address (inclusive).
* `MAX_COL_ADDR`: The maximum col address (inclusive).
* `INNER_DIM`: Set to `ROWS` or `COLS`; determines whether row or column addresses, respectively,
  are in the inner loop of all march sequences.

The BIST also stores (in flip flops) a data background pattern table (DBPT).
This table can be programmed by the scan chain or by the Rocket.
Although the table is shown for 4 bit data, the true data size is
determined by the maximum SRAM width being tested.

| Address | Data |
| --- | --- |
| 0 | 0000 |
| 1 | 1111 |
| 2 | 0101 |
| 3 | 1010 |
| 4 | 0101 |
| 5 | 0011 |
| 6 | 1100 |

The BIST supports the following instructions:
* `RESET seed`: Resets signature registers and seeds the pseudo-random number generator.
* `WAIT n`: Waits for `N` clock cycles.
* `MARCH e0 [, e1, ...] { UP | DOWN }`: marches up or down the address space,
  performing the march elements `e0`, `e1`, ...
  The possible march elements are `{READ | WRITE} pattern_address [ FLIP ]`.
  For example, the march element `READ 5 FLIP` checks that each read operation returns the bit
  sequence `1100`, which is the bitwise complement of pattern 5 in the table above.
* `RAND re0 [, re1, ...] { RA N | UP | DOWN }`: Runs a pseudo-random test.
  If `UP` or `DOWN` is specified, marches up or down (respectively) the address space,
  performing the random elements `RE0`, `RE1`, ...
  If `RA` is specified, a pseudo-random address is used. The integer `N` specifies how many
  addresses to pick. For example, `RAND OP WRITE 0, READ RA 3` picks three (not necessarily distinct)
  addresses, and for each address, writes the pattern stored in address 0 of the DBPT and then reads it back.
  Each random element has the following structure: `OP { READ | WRITE | RAND } [ DATA { pattern_address | RAND } MASK {pattern_address | 1 | RAND } ]`.
  * `OP`: can be `READ`, `WRITE`, or `RAND`. If `RAND`, an operation (read/write) will be selected pseudo-randomly.
  * `DATA`: can be a pattern address, or `RAND`. If `RAND`, data will be selected pseudo-randomly. If a pattern address is given,
    the data to write will be pulled from the data background pattern table.
  * `MASK`: can be a pattern address, `1`, or `RAND`. If `1`, the write mask will be all 1s. If `RAND`, the mask
    will be selected pseudo-randomly. If a pattern address, the mask pattern will be pulled from the DBPT.
  The `DATA` and `MASK` fields are required for `WRITE` and `RAND` operations; they must be left blank for `READ` operations.

All pseudo-random data is drawn from an LFSR.

The BIST continuously outputs a signature. This signature can be compared to an expected signature
to determine where a test has failed. On every read operation, the value read from memory
is hashed into the signature.

For march instructions, if the memory produces an incorrect
value upon read, the BIST will provide the failing instruction, the address at which the failure
occurred, the data read, and the data expected.


### Scan Chain

Each scan chain register looks approximately like this:

![Scan chain register](./figures/scan_flop.jpg)

Note that there is only one clock. So moving data in and out of the scan chains
requires toggling the global clock.

When scan enable (SE) is high, the scan chain behaves like a shift register.
Data is shifted in from the scan in (SI) port, and shifted out at the scan out (SO)
port. In the diagram above, Q and SO are always the same value.


### MMIO Structure

The table below describes the MMIO registers for a
`DxW` SRAM with `WM` mask bits and `A = clog2(D)` address bits.
`D` is the depth of the SRAM; `W` is the width.

| Name     | Width | Direction     | Description         | 
| -------- | ----- | ------------- | ------------------- |
| `addr`   | A     | R/W           | Read/write address  |
| `din`    | W     | R/W           | Write data          |
| `wmask`  | WM+1  | R/W           | `{we, wmask[WM-1:0]}` |
| `dout`   | W     | RO            | Data read from SRAM |
| `tdc`    | TBD   | RO            | TDC output code     |
| `ex`     | 1     | WO            | Set high for one cycle to begin a mem op |
| `done`   | 1     | RO            | High when a mem op completes |
| `rst`    | 1     | WO            | Reset MMIO registers |

Each SRAM operation will take approximately 5 cycles to complete:
1 cycle to set up SRAM inputs, 1 cycle for operation, and 3 cycles for TDC synchronization.
Upon completion of the operation, the `done` flag is raised. It is
set back to low when another memory operation begins (via writing to the `ex` register),
or upon writing to the `rst` register.

There are also MMIO registers for the BIST.

| Name     | Width | Direction     | Description         | 
| -------- | ----- | ------------- | ------------------- |
| `bist_rst` | 1   | WO            | BIST reset          |
| `bist_start_pattern` | 4   | R/W | BIST starting pattern |
| `bist_status` | 32 | RO            | `{done, fail, pattern, location}` |
| `bist_expected` | W | RO            | BIST expected data |
| `bist_received` | W | RO            | BIST received data |


* Address
* Write mask
* Data in
* Data out
* BIST fail flag, addr, expected, received, pattern, location within pattern.
  For example, "BIST failed on address 0x123. Expected data 0x123, got 0x124 at pattern 2, step number 4".

### TDC Configuration

The TDC takes as input an early clock and a late clock. It measures the time difference between
a rising edge of the early clock and a rising edge of the late clock, and produces a
thermometer-encoded digital signal. In the absence of rising edges on the late clock,
the TDC value is held constant.


## PLL

Sean may provide a BAG/Hammer-generated PLL instance,
with Spice/GDS/LEF/LIB collateral.

A global clock mux selects between the PLL-generated clock
and an externally-provided clock.
